\documentclass[12pt,a4paper]{article}
\usepackage[utf-8]{inputenc}
\usepackage[spanish]{babel}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{listings}
\usepackage{geometry}

\geometry{margin=1in}

\theoremstyle{definition}
\newtheorem{definition}{Definición}[section]
\newtheorem{theorem}{Teorema}[section]
\newtheorem{lemma}{Lema}[section]
\newtheorem{corollary}{Corolario}[section]
\newtheorem{proposition}{Proposición}[section]

\lstset{
    language=Python,
    basicstyle=\ttfamily\small,
    keywordstyle=\color{blue},
    commentstyle=\color{gray},
    stringstyle=\color{red},
    breaklines=true,
    tabsize=4
}

\title{Informe Técnico: Algoritmo Backtracking para\\el Problema de Selección Óptima de Talento}
\author{Análisis y Complejidad}
\date{\today}

\begin{document}

\maketitle

\tableofcontents
\newpage

\section{Introducción}

En este informe se presenta un análisis formal del problema de selección óptima de freelancers que se enfrenta en TalentBridge Connect, así como el algoritmo de \textbf{Backtracking con Poda} implementado para resolverlo.

El problema consiste en encontrar el conjunto de empleados de costo mínimo que cubra todos los requisitos de habilidades especificados por un cliente, asegurando que cada habilidad requerida sea cubierta por al menos un empleado con el nivel de dominio mínimo exigido.

\section{Modelación Matemática del Problema}

\subsection{Definición Formal}

\begin{definition}[Problema de Cobertura de Habilidades Ponderado]

Sea:
\begin{itemize}
    \item $E = \{e_1, e_2, \ldots, e_n\}$ el conjunto de empleados disponibles
    \item $S = \{s_1, s_2, \ldots, s_m\}$ el conjunto de habilidades disponibles en el sistema
    \item Para cada empleado $e_i \in E$: 
    \begin{itemize}
        \item $c_i \in \mathbb{R}^+$ su costo por hora (salario)
        \item $L_i(s) \in \{0\} \cup [1, 10]$ el nivel de dominio en la habilidad $s$, donde $0$ indica que no posee la habilidad
    \end{itemize}
    \item $R = \{(s_j, l_j) : s_j \in S, l_j \in [1, 10]\}$ el conjunto de requerimientos del cliente, donde $(s_j, l_j)$ significa que se requiere habilidad $s_j$ con nivel mínimo $l_j$
\end{itemize}

El problema consiste en encontrar un subconjunto $X \subseteq E$ tal que:

\begin{equation}
\min \sum_{e_i \in X} c_i
\end{equation}

sujeto a la restricción de cobertura:

\begin{equation}
\forall (s_j, l_j) \in R, \exists e_i \in X : L_i(s_j) \geq l_j
\end{equation}

Es decir, todo requerimiento debe ser cubierto por al menos un empleado seleccionado con el nivel de dominio suficiente.

\end{definition}

\subsection{Relación con Problemas Clásicos de Complejidad}

Este problema es una \textbf{variante ponderada del Weighted Set Cover Problem} (WSC), uno de los problemas NP-Hard más estudiados en ciencia de la computación.

\subsubsection{Mapeo al Problema de Cobertura de Conjuntos}

Podemos transformar formalmente nuestro problema en una instancia de WSC:

\begin{itemize}
    \item El universo $U$ está compuesto por todos los pares (habilidad, nivel): $U = R$
    \item Cada empleado $e_i$ representa un conjunto $A_i = \{(s, l) \in R : L_i(s) \geq l\}$, es decir, el conjunto de requisitos que puede cubrir
    \item El peso de cada conjunto es $w(A_i) = c_i$ (costo del empleado)
    \item El objetivo es encontrar $X \subseteq E$ tal que $\bigcup_{e_i \in X} A_i = U$ minimizando $\sum_{e_i \in X} c_i$
\end{itemize}

Esta transformación es una reducción polinomial que preserva soluciones óptimas.

\section{Demostración de NP-Hardness}

\begin{theorem}[NP-Hardness del Problema de Cobertura de Habilidades Ponderado]

El problema de selección óptima de talento es NP-Hard.

\end{theorem}

\begin{proof}

La demostración procede por reducción polinomial del \textbf{Problema de Cobertura de Conjuntos Ponderado} (WSC), que es conocidamente NP-Hard (demostrado por Karp en 1972).

\textbf{Paso 1: Reducción Polinomial}

Dado una instancia del WSC: $(U, \mathcal{A}, w)$ donde:
\begin{itemize}
    \item $U = \{u_1, u_2, \ldots, u_m\}$ es el universo
    \item $\mathcal{A} = \{A_1, A_2, \ldots, A_n\}$ donde cada $A_i \subseteq U$
    \item $w : \mathcal{A} \to \mathbb{R}^+$ es la función de peso
\end{itemize}

Construimos una instancia de nuestro problema en tiempo polinomial:

\begin{itemize}
    \item Para cada $u_j \in U$, creamos una habilidad abstracta $s_j$ con requerimiento $(s_j, 1)$
    \item Para cada $A_i \in \mathcal{A}$, creamos un empleado $e_i$ con:
    \begin{itemize}
        \item Costo $c_i = w(A_i)$
        \item Habilidades: $L_i(s_j) = 1$ si $u_j \in A_i$, $L_i(s_j) = 0$ en caso contrario
    \end{itemize}
    \item El cliente requiere todas las habilidades: $R = \{(s_1, 1), (s_2, 1), \ldots, (s_m, 1)\}$
\end{itemize}

\textbf{Paso 2: Equivalencia de Soluciones}

Una solución óptima $X^*$ para la instancia del WSC corresponde exactamente a una solución óptima $X^*$ de nuestro problema:

\begin{itemize}
    \item Si $\bigcup_{A_i \in X^*} A_i = U$ en WSC, entonces $X^*$ cubre todos los requerimientos en nuestro problema
    \item El costo total es idéntico: $\sum_{e_i \in X^*} c_i = \sum_{A_i \in X^*} w(A_i)$
    \item Inversamente, cualquier solución de nuestro problema proporciona una solución válida del WSC
\end{itemize}

\textbf{Paso 3: Conclusión}

Como WSC es NP-Hard y existe una reducción polinomial desde WSC a nuestro problema, el problema de selección óptima de talento es también NP-Hard.

Además, es evidente que el problema pertenece a NP, ya que dada una solución candidata $X$, puede verificarse en tiempo polinomial si:
\begin{enumerate}
    \item Todos los requerimientos son cubiertos (recorrer $|R|$ requisitos y verificar cobertura)
    \item El costo total es válido (sumar $|X|$ costos)
\end{enumerate}

Por lo tanto, el problema es \textbf{NP-Completo}.

\end{proof}

\begin{corollary}
Bajo la conjetura $P \neq NP$, no existe un algoritmo de tiempo polinomial que resuelva nuestro problema de forma óptima. Los mejores algoritmos conocidos tienen complejidad exponencial en el peor caso.
\end{corollary}

\section{Entidades del Problema}

\subsection{Estructura de Datos: Skill}

\begin{definition}[Habilidad]
Una \textbf{habilidad} (Skill) es una capacidad profesional discreta en el dominio de la ingeniería de software y diseño.

Implementación: Enumeración con 7 valores posibles:
\begin{itemize}
    \item JavaScript
    \item Python
    \item Java
    \item C\#
    \item C++
    \item UI/UX Design
    \item Data Science
\end{itemize}

Los niveles de dominio se representan en una escala de 1 a 10, donde:
\begin{itemize}
    \item 1: Nivel básico
    \item 5: Nivel intermedio
    \item 10: Nivel experto
\end{itemize}
\end{definition}

\subsection{Estructura de Datos: Employee}

\begin{definition}[Empleado]
Un \textbf{empleado} (Employee) representa un freelancer disponible en la plataforma.

Atributos:
\begin{itemize}
    \item $\text{id} \in \mathbb{Z}^+$: Identificador único
    \item $\text{name} \in \Sigma^*$: Nombre del empleado
    \item $\text{salary\_per\_hour} \in \mathbb{R}^+$: Tarifa horaria (costo)
    \item $\text{skills} : \text{Skill} \to [1, 10]$: Función parcial que mapea habilidades a niveles de dominio
\end{itemize}

Operaciones principales:
\begin{itemize}
    \item $\text{has\_skill}(s, l)$: Verifica si posee la habilidad $s$ con nivel $\geq l$
    \item $\text{covers\_requirements}(R)$: Retorna el conjunto de requerimientos cubiertos
    \item $\text{efficiency}(R)$: Métrica para algoritmos greedy = $\frac{|\text{requisitos cubiertos}|}{\text{costo}}$
\end{itemize}
\end{definition}

\subsection{Estructura de Datos: Client}

\begin{definition}[Cliente]
Un \textbf{cliente} (Client) representa una solicitud de proyecto con requisitos específicos.

Atributos:
\begin{itemize}
    \item $\text{requirements} : \text{Skill} \to [1, 10]$: Mapeo de habilidades requeridas a niveles mínimos
\end{itemize}

Propiedades:
\begin{itemize}
    \item $\text{num\_requirements}$: Número de habilidades requeridas $|R|$
    \item $\text{required\_skills}$: Conjunto de habilidades demandadas
\end{itemize}

Validación: Los niveles deben estar en el rango $[1, 10]$.
\end{definition}

\subsection{Estructura de Datos: Solution}

\begin{definition}[Solución]
Una \textbf{solución} (Solution) representa una propuesta de equipo de empleados.

Atributos:
\begin{itemize}
    \item $\text{employees} \subseteq E$: Conjunto de empleados seleccionados
    \item $\text{total\_cost} = \sum_{e \in \text{employees}} c_e$: Costo total
    \item $\text{is\_valid} \in \{\text{True}, \text{False}\}$: Indicador de validez (si cubre todos los requerimientos)
\end{itemize}
\end{definition}

\section{Algoritmo de Backtracking con Poda}

\subsection{Descripción del Algoritmo}

El algoritmo de \textbf{Backtracking con Poda (Branch and Bound)} explora el espacio de soluciones de forma sistemática, eliminando ramas (branches) que demostablemente no pueden conducir a una solución mejor que la actual.

\subsubsection{Pseudocódigo}

\begin{algorithm}[H]
\caption{Backtracking con Poda para Selección de Talento}
\begin{algorithmic}[1]
\Function{Backtrack}{$\text{pos}, \text{selected}, \text{current\_cost}$}
    \State \textbf{Poda por Costo}: \textbf{if} $\text{current\_cost} \geq \text{best\_solution.cost}$ \textbf{then} \textbf{return}
    
    \State \textbf{Verificación de Solución}: \textbf{if} $\text{is\_complete\_cover}(\text{selected})$ \textbf{then}
    \State \quad \text{best\_solution} $\gets$ \text{Solution}(\text{selected}, \text{current\_cost})
    \State \quad \textbf{return}
    \State \textbf{end if}
    
    \State \textbf{Caso Base}: \textbf{if} $\text{pos} \geq |\text{employees}|$ \textbf{then} \textbf{return end if}
    
    \State \textbf{Poda por Factibilidad}: $\text{uncovered} \gets \text{get\_uncovered\_requirements}(\text{selected})$
    \State \textbf{if} $\neg \text{can\_potentially\_cover}(\text{pos}, \text{uncovered})$ \textbf{then} \textbf{return end if}
    
    \State $\text{employee} \gets \text{employees\_list}[\text{pos}]$
    
    \State \textbf{Rama 1 - Incluir}: \textbf{if} $\text{can\_cover\_any\_requirement}(\text{employee}, \text{uncovered})$ \textbf{then}
    \State \quad \text{selected.add}(\text{employee})
    \State \quad \Call{Backtrack}{pos+1, selected, current\_cost + employee.salary}
    \State \quad \text{selected.remove}(\text{employee})
    \State \textbf{end if}
    
    \State \textbf{Rama 2 - Excluir}:
    \State \quad \Call{Backtrack}{pos+1, selected, current\_cost}
\EndFunction
\end{algorithmic}
\end{algorithm}

\subsection{Estrategias de Poda}

El algoritmo implementa dos estrategias de poda (Branch and Bound) críticas para reducir el espacio de búsqueda:

\subsubsection{Poda por Costo (Cost Pruning)}

\begin{definition}[Poda por Costo]
Si el costo acumulado $\text{current\_cost}$ en un nodo del árbol de búsqueda es mayor o igual al mejor costo encontrado hasta ahora ($\text{best\_cost}$), la rama se elimina:

\[
\text{if } \text{current\_cost} \geq \text{best\_cost} \text{ then prune}
\]

Justificación: Cualquier continuación de esta rama solo puede aumentar o mantener el costo, por lo que nunca podrá mejorar la mejor solución actual.
\end{definition}

Complejidad de esta verificación: $O(1)$.

\subsubsection{Poda por Factibilidad (Feasibility Pruning)}

\begin{definition}[Poda por Factibilidad]
Si el conjunto de empleados no seleccionados a partir de la posición actual ($\text{pos}$) no puede potencialmente cubrir todos los requerimientos no cubiertos, la rama se elimina.

Sea $\text{uncovered}(X)$ el conjunto de requerimientos no cubiertos por $X$, y $\text{remaining}(pos) = \{e_i : i \geq pos\}$ el conjunto de empleados restantes:

\[
\text{if } \bigcup_{e_i \in \text{remaining}(pos)} \text{covers}(e_i) \not\supseteq \text{uncovered}(X) \text{ then prune}
\]

Justificación: Si es matemáticamente imposible cubrir todos los requerimientos con los empleados disponibles, esta rama no puede producir una solución válida.
\end{definition}

Complejidad de esta verificación: $O(n \cdot m)$ donde $n$ es el número de empleados restantes y $m$ es el número de requerimientos.

\subsection{Decisiones de Ramificación}

En cada nodo, el algoritmo realiza dos decisiones:

\begin{enumerate}
    \item \textbf{Incluir empleado}: Solo si el empleado puede cubrir al menos un requerimiento no cubierto (evita incluir empleados innecesarios)
    \item \textbf{Excluir empleado}: Exploración alternativa
\end{enumerate}

Esta estructura de ramificación binaria genera un árbol de decisión con profundidad igual al número de empleados.

\section{Correctitud del Algoritmo}

\begin{theorem}[Correctitud del Backtracking]

Si el algoritmo termina, retorna una solución óptima (si existe) o declara que no existe solución válida.

\end{theorem}

\begin{proof}

La demostración de correctitud se basa en tres propiedades:

\textbf{1. Completitud}

El algoritmo explora todas las soluciones posibles válidas:
\begin{itemize}
    \item El árbol de búsqueda enumera todos los $2^n$ subconjuntos de empleados
    \item Las podas solo eliminan ramas que demostablemente no contienen soluciones mejores
    \item Si existe una solución óptima, su correspondiente rama nunca es podada
\end{itemize}

Formalmente, sea $X^*$ una solución óptima. En el árbol de búsqueda existe un camino (secuencia de decisiones de inclusión/exclusión) que construye exactamente $X^*$. Para cualquier nodo en este camino:
\begin{itemize}
    \item Poda por costo: $\sum_{e_i \in X^* \cap \{e_1, \ldots, e_{\text{pos}}\}} c_i < \text{best\_cost}$ al inicio, por lo que no se poda
    \item Poda por factibilidad: $X^*$ demuestra que es factible cubrir los requerimientos con empleados posteriores
\end{itemize}

Por lo tanto, el camino que construye $X^*$ nunca es podado.

\textbf{2. Validez}

Solo se registran soluciones que cumplen todos los requerimientos:

\[
\text{best\_solution} \gets X \iff \forall (s, l) \in R, \exists e \in X : L_e(s) \geq l
\]

La función \texttt{is\_complete\_cover} verifica esta condición explícitamente antes de registrar cualquier solución.

\textbf{3. Optimalidad}

El algoritmo mantiene la solución con costo mínimo entre todas las encontradas:

\begin{itemize}
    \item Inicialmente: $\text{best\_solution.cost} = \infty$ (ninguna solución válida)
    \item En cada actualización: $\text{best\_solution.cost}$ disminuye (solo se actualiza si es mejor)
    \item Al finalizar: $\text{best\_solution}$ contiene el costo mínimo explorado
\end{itemize}

Combinando completitud y validez: todas las soluciones válidas son exploradas, y la mejor se registra.

\end{proof}

\begin{proposition}[Correctitud de la Poda por Factibilidad]

La poda por factibilidad preserva la optimalidad de la solución encontrada.

\end{proposition}

\begin{proof}

Sea un nodo en la ejecución donde se aplica poda por factibilidad: $\text{uncovered} = \text{get\_uncovered\_requirements}(\text{selected})$ y $\text{remaining}(pos)$ es el conjunto de empleados no considerados aún.

Si $\bigcup_{e_i \in \text{remaining}(pos)} \text{covers}(e_i) \not\supseteq \text{uncovered}$, entonces:

\[
\forall X \subseteq \text{remaining}(pos) : \text{selected} \cup X \text{ no es una solución válida}
\]

Por lo tanto, cualquier continuación de esta rama en el árbol de búsqueda no puede llevar a una solución válida. Podando esta rama no se elimina ninguna solución óptima del espacio de búsqueda.

\end{proof}

\section{Análisis de Complejidad}

\subsection{Complejidad Temporal}

\subsubsection{Peor Caso: $O(2^n)$}

\begin{theorem}[Complejidad Temporal del Peor Caso]

La complejidad temporal del algoritmo de backtracking en el peor caso es $\Theta(2^n)$, donde $n = |E|$ es el número de empleados.

\end{theorem}

\begin{proof}

\textbf{Estructura del árbol de búsqueda:}

El árbol de decisión tiene estructura binaria:
\begin{itemize}
    \item Profundidad: $n$ (decisión para cada uno de los $n$ empleados)
    \item Grado: 2 (incluir o excluir)
    \item Número de nodos: hasta $2^{n+1} - 1$
\end{itemize}

En el peor caso, si:
\begin{enumerate}
    \item No existen soluciones válidas (sin poda por factibilidad)
    \item Todos los empleados tienen costos muy similares (sin poda por costo efectiva)
    \item Cada empleado contribuye de forma marginal a la cobertura
\end{enumerate}

el algoritmo explora el árbol completo.

\textbf{Trabajo por nodo:}

En cada nodo se realiza:
\begin{itemize}
    \item Poda por costo: $O(1)$
    \item Obtener requerimientos no cubiertos: $O(n \cdot m)$
    \item Poda por factibilidad: $O(n \cdot m)$
    \item Verificación de si el empleado cubre algún requisito: $O(m)$
\end{itemize}

donde $m = |R|$ es el número de requerimientos. En total, $O(n \cdot m)$ por nodo.

\textbf{Complejidad total:}

\[
T(n) = O(2^n) \text{ nodos} \times O(n \cdot m) \text{ por nodo} = O(2^n \cdot n \cdot m)
\]

Sin embargo, el análisis estándar de backtracking omite los factores polinomiales para $n$ en la notación asintótica, ya que el factor exponencial domina:

\[
T(n) = \Theta(2^n)
\]

\end{proof}

\subsubsection{Caso Promedio: Mejora Significativa}

En la práctica, las estrategias de poda reducen dramáticamente la complejidad:

\begin{proposition}[Efectividad de la Poda]

Con las dos estrategias de poda implementadas:
\begin{enumerate}
    \item Cuando existe una solución válida de costo razonable, la poda por costo elimina un porcentaje significativo del árbol
    \item Cuando los empleados tienen cobertura limitada, la poda por factibilidad elimina ramas inviables tempranamente
\end{enumerate}

Empiricamente, en instancias prácticas, el número de nodos visitados se reduce a $O(c^n)$ donde $c < 2$ (típicamente $c \in [1.2, 1.8]$).

\end{proposition}

\subsection{Complejidad Espacial}

\begin{theorem}[Complejidad Espacial]

La complejidad espacial del algoritmo es $O(n + m)$.

\end{theorem}

\begin{proof}

El espacio utilizado comprende:

\begin{enumerate}
    \item \textbf{Pila de recursión}: Profundidad máxima de $n$, cada llamada almacena:
    \begin{itemize}
        \item $\text{pos}$: índice entero ($O(1)$)
        \item $\text{selected}$: conjunto de empleados ($O(n)$ espacio, pero $O(\log n)$ amortizado en implementaciones eficientes con vectores de bits)
        \item $\text{current\_cost}$: número real ($O(1)$)
    \end{itemize}
    
    \item \textbf{Estructuras auxiliares}:
    \begin{itemize}
        \item $\text{employees\_list}$: lista de $n$ empleados ($O(n)$)
        \item $\text{best\_solution}$: una solución ($O(n)$)
        \item Funciones auxiliares (get\_uncovered\_requirements, etc.): $O(m)$ espacio temporal
    \end{itemize}
\end{enumerate}

Sumando todas las contribuciones:

\[
S(n) = O(n \cdot \text{depth}) + O(n) + O(m) = O(n \cdot n) + O(m) = O(n^2 + m)
\]

Sin embargo, si se optimiza el conjunto \texttt{selected} utilizando un vector de bits en lugar de un conjunto explícito:

\[
S(n) = O(n) + O(m) = O(n + m)
\]

\end{proof}

\subsection{Tabla Comparativa de Complejidad}

\begin{center}
\begin{tabular}{|l|c|c|}
\hline
\textbf{Análisis} & \textbf{Complejidad} & \textbf{Comentario} \\
\hline
Mejor caso & $O(n \cdot m)$ & Solución encontrada rápidamente \\
Caso promedio & $O(c^n \cdot n \cdot m)$, $c < 2$ & Con poda efectiva \\
Peor caso & $O(2^n \cdot n \cdot m)$ & Sin poda significativa \\
Espacio & $O(n + m)$ & Con optimizaciones \\
\hline
\end{tabular}
\end{center}

\section{Análisis Comparativo con Otras Estrategias}

\subsection{Backtracking vs. Greedy}

\begin{itemize}
    \item \textbf{Backtracking}: Garantiza solución óptima, $O(2^n)$ temporal, ideal para instancias pequeñas-medianas
    \item \textbf{Greedy}: Selecciona empleados por máxima eficiencia, $O(n^2 \cdot m)$ temporal, pero no garantiza optimalidad. Factor de aproximación: $O(\log n)$
\end{itemize}

\subsection{Backtracking vs. Programación Dinámica}

\begin{itemize}
    \item \textbf{Backtracking}: Exploración exhaustiva con poda inteligente
    \item \textbf{Programación Dinámica}: Construcción de tabla de subestructuras óptimas. Para este problema, el espacio de estado es complejo debido a la naturaleza multiset del problema de cobertura
\end{itemize}

El backtracking es más adecuado cuando se espera que la poda sea efectiva (soluciones viables de bajo costo).

\section{Conclusiones}

\begin{enumerate}
    \item El problema de selección óptima de talento es una variante del \textbf{Weighted Set Cover Problem}, que es NP-Completo
    
    \item El algoritmo de \textbf{Backtracking con Poda} implementado garantiza encontrar la solución óptima, aunque con complejidad exponencial $O(2^n)$ en el peor caso
    
    \item Las estrategias de poda (por costo y factibilidad) reducen significativamente el espacio de búsqueda en la práctica, haciendo el algoritmo viable para instancias de tamaño moderado
    
    \item La complejidad espacial es $O(n + m)$, lo que permite manejar instancias con muchos empleados y requisitos
    
    \item Para instancias muy grandes, este enfoque debe complementarse con heurísticas (Greedy, Búsqueda Local) o algoritmos aproximados
\end{enumerate}

\end{document}
